# 쉽게 배우는 알고리즘 - 최단경로 

문병로 지음

## 음의 가중치 허용 X - Dijkstra

```python
def Dijkstra(G, r):
    G = (V, E) # 주어진 그래프 
    r # 시작으로 삼을 정점 
	S = []
	
	for u in V:
		d[u] = INF # d[u] => r 에서 u 까지 이르는 거리 저장.
	d[r] = 0 
	
	while (S != V): # n 회 순환 
		u = extractMin(V-S, d) # V-S 에서 d 값이 가장 작은 정점 u 를 리턴
        S.append(u)
        for v in L(u): # 정점 u 로부터 연결된 정점들의 집합 L(u)
            if v in V-S and d[v] = d[u] + w(u, v):
                d[v] = d[u] + w(u, v) # relaxation 
                prev[v] = u
```

- 최소 신장 트리를 위한 프림 알고리즘과 원리가 거의 같다. 다만 프림 알고리즘에서는 d[v] 가 정점 v 를 신장 트리에 연결하는 최소 비용을 위해 사용되는 반면, 다익스트라 알고리즘에서는 d[v] 가 정점 r 에서 정점 v 에 이르는 최단 거리를 위해 사용된다. 
- 프림 알고리즘과 거의 같고, 수행시간도 동일하다. 
  - 힙을 이용하면 O( _E_ logV) 시간이 소요된다. 
- 다익스트라 알고리즘은 간선의 가중치가 음이 되면 작동하지 않는다. 다익스트라 알고리즘은 임의의 정점을 집합 S 에 더할 때 r에서 그 정점까지의 최단 거리는 계산이 끝났다는 확신을 가지고 더한다.  이후에 더 짧은 경로가 존재한다면 다익스트라 알고리즘의 논리적 기반이 무너진다. 

## 음의 가중치 허용 - Bellman-Ford

- 벨만 포드 알고리즘은 간선을 최대 1개 사용하는 최단 경로, 간선을 최대 2개 사용하는 최단 경로, ... 식으로 간선을 최대 n-1 개 사용하는 최단 경로까지 구해나간다. 

```python
def BellmanFord(G, r):
    for u in V:
        d[u] = INF
    d[r] = 0
    
    for i in range(len(V)-1): # N-1 번 relaxation 
        for u, v in E:
            if d[v] > d[u] + w(u, v):
                d[v] = d[u] + w(u, v)
                prev[v] = u
	
    # 사이클이 없다는 것은, 간선을 최대 N-1 개 사용했을 때, 최단 경로를 구할 수 있음을 뜻한다.  
    # 음의 사이클 존재 여부 확인
    for u, v in E: 
        if d[v] > d[u] + w(u, v):
            # N 번째 relaxation 
            # 음의 사이클 발견! => 해 없음.
```



## 모든 쌍 최단 경로 - Floyd-Warshall 

**플로이드 워셜 알고리즘** 

- 모든 노드에서 다른 모드 까지의 최단 경로를 모두 계산한다. 

- 다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘을 수행한다. 

  - 다만 매 단계마다 방문하지 않은 노드 중에 최단 거리를 갖는 노드를 찾는 과정이 필요하지 않다.

- 2차원 테이블에 최단 거리 정보를 저장한다. 

- 다이나믹 프로그래밍 유형에 속한다. 

- 점화식 

  ​		D~a~~b~ = min ( D~a~~b~, D~a~~k~ + D~k~~b~)

  각 단계마다 특정한 노드 k 를 거쳐 가는 경우를 확인하여, a 에서 b 로 가는 최단 거리보다, a 에서 k 를 거쳐 b 로 가는 거리가 더 짧은지 검사한다. 

- 시간 복잡도
  - 삼중 for loop 을 거치므로, 그래프의 크기가 작아(노드와 간선의 개수가 적을 때) 세제곱 시간 알고리즘을 적용해도 문제 없을 때 사용하는 것이 좋다. 

```python
def simpleShortestPath:
    for i in range(1, N+1):
        for j in range(1, N+1):
            d[i][j] = w[i][j] # 중간 정점을 거치지 않는 경우로 초기화 
	
    
    for k in range(1, N+1):
        for i in range(1, N+1):
            for j in range(1, N+1):
                d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k] + d[k-1][k][j])
                # k 번 중간 정점을 거친 최단 거리는, k-1 번 중간 정점을 거친 최단 거리를 통해 구한다. 
```

@ 2021-12-15 추가 

- 최단 사이클을 찾을 때도 유용하다 
- dp[v][v] => 자기 자신으로 돌아오는 사이클의 경로 

## DAG 에서 최단 경로 - 위상 정렬

- DAG 에서는 모든 정점을 한 줄로 늘어놓을 때, 뒤에 위치한 정점부터 앞에 위치한 정점으로 가는 간선은 존재하지 않도록 하는 정점들의 순열이 존재한다. => 위상 정렬로 얻을 수 있다. 

- 정점들을 위상 정렬한 뒤에, 위상 정렬 순서로 relaxation

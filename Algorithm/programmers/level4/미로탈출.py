"""
    # 문제 해설
    먼저, TRAP이 없다고 가정해 봅시다. 
    그러면 이 문제는 가중치가 양수인 간선만 있는 그래프에서의 두 노드 간의 최단거리를 찾는 문제로, 
    인접 리스트를 사용해 그래프를 구현한 후 다익스트라 알고리즘을 사용해서 해결할 수 있습니다.

    TRAP이 있는 경우는 어떻게 해야 할까요? 문제의 조건에서, TRAP 노드의 최대 개수는 10입니다. 
    즉, TRAP 노드의 수가 적기 때문에 다익스트라 알고리즘을 사용하면서 
    그래프의 상태(즉, 어떤 노드에 연결된 간선들이 뒤집어져 있는지)까지 고려할 수 있습니다. 
    다익스트라 알고리즘에서 특정 노드를 방문하고, 다음 방문할 노드를 우선순위 큐에 넣는 과정에서 
    그래프의 상태를 확인하여 그 노드로 들어오는 간선과 노드에서 나가는 간선 중 사용 가능한 간선만을 골라서 사용하게 되는 것입니다. 
    일반적인 다익스트라 알고리즘 구현에서는 노드에서 나가는 간선만 고려하면 되지만, 
    이 문제에서는 들어오는 간선도 TRAP으로 인해 나가는 간선으로 바뀔 수 있기 때문에 모두 확인해 주어야 합니다. 
    또한, 원래의 다익스트라 알고리즘에서는 한 번 방문한 노드는 다시 방문할 필요가 없으나, 
    이 문제에서는 입출력 예 #2에서처럼 한 번 방문한 노드를 다시 방문해야 하는 경우도 있습니다. 
    이 경우는 방문할 때마다 그래프의 상태가 달랐기 때문으로, 
    다익스트라 알고리즘에서 “이미 방문한 정점”을 확인할 때 그래프의 상태가 달라진 경우에는 제외해서는 안 됩니다.

    설명대로 구현한 경우, 그래프의 상태가 최대 2^10 = 1024 개 존재할 수 있으므로 
    간선과 정점의 수가 1024배로 늘어난 상태에서 다익스트라 알고리즘을 구현하는 것과 같으므로, 
    제한 시간 안에 문제를 해결할 수 있습니다.
"""
# from collections import deque    

def solution(n, start, end, roads, traps):
    pass

solution(3, 1, 3, [[1, 2, 2], [3, 2, 3]], [2])
solution(4, 1, 4, [[1, 2, 1], [3, 2, 1], [2, 4, 1]], [2, 3])


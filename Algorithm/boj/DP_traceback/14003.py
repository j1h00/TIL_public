"""
    수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

    예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 
    가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

    # 입력 
    첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.
    둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)

    # 출력 
    첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.
    둘째 줄에는 가장 긴 증가하는 부분 수열을 출력한다. 
    그러한 수열이 여러가지인 경우 아무거나 출력한다.
"""
# 12738 가장 긴 증가하는 부분수열 3 과 입력 조건이 동일하다. 
# 이분 탐색을 이용해야 할듯. 
# 그러나 12738 이분탐색은, 부분수열 최대 길이를 알아내는 데에는 사용 가능하나, 
# 올바른 부분수열을 보장하지는 않는다. 
# 따라서, 
# 1. 이분탐색을 통해 부분 수열의 최대 길이를 알아내고, 
# 2. 다른 기록 배열을 하나 이용하여 각 수마다 가질 수 있는 수열의 최대길이를 저장한 뒤 
#   1과 일치하는 최대 길이를 찾아서 역순으로 탐색하며 내려온다. 
# 이 방법으로 찾은 배열은 최대 길이 부분 수열을 보장한다.
import sys
import bisect

N = int(sys.stdin.readline())
A = [int(_) for _ in sys.stdin.readline().split()]

# 해당 인덱스에서의 부분 수열의 최대 길이, 
max_length = [0]*N # ex) max_length[3] 은 A[3] 까지의 부분 수열의 최대 길이
max_length[0] = 1 
dp = [A[0]] # 최대 길이를 찾기 위해 


for i in range(N):
    if A[i] > dp[-1]: # 만약 A[i] 가 현재 dp 에 저장된 수열의 끝보다 크다면 
        dp.append(A[i]) # 부분 수열에 추가해준다!
        max_length[i] = len(dp) # A[i] 까지의 부분 수열 최대 길이는 len(dp) 와 같음.
    else: 
        idx = bisect.bisect_left(dp, A[i]) # 만약 크지 않다면, 부분 수열에서 A[i] 의 위치를 찾는다. 
        dp[idx] = A[i] # dp[idx] 를 A[i] 로 교체한다. => 12015 풀이 참고  
        max_length[i] = idx + 1 # 마찬가지로 A[i] 까지의 부분 수열 최대 길이를 업데이트 

answer1 = len(dp)
print(answer1)

answer2 = []
for i in range(N-1, -1, -1): # max_length 를 거꾸로 탐색하면서, 
    if max_length[i] == answer1: # 최대 길이를 만나면 
        answer2.append(A[i]) # answer2(최종 수열) 에 포함시킨다. 
        answer1 -= 1 # 최대 길이를 1 감소. 
print(*answer2[::-1])
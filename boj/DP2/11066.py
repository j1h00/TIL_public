"""
    소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 
    소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다.
    이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 
    이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 소설의 여러 장들이 연속이 되도록 파일을 합쳐나가고, 
    최종적으로는 하나의 파일로 합친다. 
    두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 
    최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.

    소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 
    이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.
"""
# 예제를 보니, 파일을 합치는 순서에 따라 필요한 비용의 총 합이 달라진다. 
# 너무 어려워서 풀이를 찾아 보았다. 
# https://data-make.tistory.com/402
# 2차원 DP 를 사용한다. 
# dp[i][j] 를 i 에서 j 까지 합하는데 필요한 최소 비용이라고 하자. 

# 예를 들어, dp[0][2] 는 0 에서 2까지 합하는데 필요한 최소 비용이다. 
# 이 때, dp[0][2] 를 구하는 것은 두 가지 방법으로 생각해 볼 수 있다. 
# 1. dp[0][1] + dp[2][2]
# 2. dp[1][2] + dp[0][0]
# (0, 2 를 합친 뒤 1을 합치는 것은 안된다(문제 조건에 따라, 소설은 연속된 장들만 합칠 수 있다.)
# 1 과 2 중에 최소 비용을 선택하면 된다!

# 만약 dp[0][3] 과 같이 길이가 4인 경우엔 3가지 방법
# 1. dp[0][2] + dp[3][3]
# 2. dp[0][0] + dp[1][3]
# 3. dp[0][1] + dp[2][3] 
# 따라서 dp[i][j] = dp[i][i+k] + dp[i+k+1][j] 와 같은 점화식이 성립한다. 
# pypy 로 통과 
T = int(input())

for i in range(T):
    K = int(input())
    cost = list(map(int, input().split()))
    cost_sum = [0] # cost_sum[0] = 0 => 추후에 구간합 구하기 편하다. 
    for i in range(K):
        cost_sum.append(cost_sum[-1] + cost[i])

    dp = [[0]*K for _ in range(K)]
    for l in range(2, K+1): # l : len (부분 소설의 길이)
        for i in range(K - l + 1): # i : 시작 인덱스 
            j = i + l - 1 # j : 끝 인덱스 
            dp[i][j] = 10**9 # min 사용을 위해 초기화 
            for k in range(l-1): # 중간 k 를 기준으로 둘로 나눈다. (경우를 나눔)
                dp[i][j] = min(dp[i][j], dp[i][i+k] + dp[i+k+1][j]) # 경우 중 최솟값을 찾은 뒤에
            dp[i][j] += (cost_sum[j+1] - cost_sum[i]) # 구간합을 더해준다. ex) 0 ~ 2 까지의 합 = cost_sum[3] - cost_sum[0] 
            # 마지막에 구간 총합을 더하는 이유는, 직접 해보면 안다!!!
    
    print(dp[0][K-1])


# CS_basic : Operating System

기본적인 CS 지식을 복습하기 위해 정리한 글입니다. 

상세한 학습 내용은 [OS](./OS) 에도 담겨있습니다. 

>출처 
>
>[📖Tech Interview for developer : 신입 개발자 전공 지식 & 기술 면접 백과사전 ](https://gyoogle.dev/blog/)

## Operating System

### Intro

일반적으로 `하드웨어를 관리하고, 응용 프로그램과 하드웨어 사이에서 인터페이스 역할을 하며 시스템의 동작을 제어하는 시스템 소프트웨어`로 정의한다.

운영체제는 **시스템의 자원과 동작을 관리하는 소프트웨어**다.

출처의 글에선 크게 아래와 같이 분류하였다. 

###### 1. 프로세스 관리 

운영체제에서 작동하는 응용 프로그램을 관리하는 기능이다.

어떤 의미에서는 프로세서(CPU) 관리하는 것이라고 볼 수도 있다. 현재 CPU를 점유해야 할 프로세스를 결정하고, 실제로 CPU를 프로세스에 할당하며, 이 프로세스 간 공유 자원 접근과 통신 등을 관리하게 된다.

- 프로세스, 스레드
- 스케줄링
- 동기화
- IPC 통신

###### 2. 저장장치 관리 

1차 저장장치에 해당하는 메인 메모리와 2차 저장장치에 해당하는 하드디스크, NAND 등을 관리하는 기능이다.

- 메모리 관리 
- 가상 메모리
- 파일 시스템

###### 3. 네트워킹 

TCP/IP 기반의 인터넷에 연결하거나, 응용 프로그램이 네트워크를 사용하려면 **운영체제에서 네트워크 프로토콜을 지원**해야 한다. 현재 상용 OS들은 다양하고 많은 네트워크 프로토콜을 지원한다.

- TCP/IP
- 기타 프로토콜

###### 4. 사용자 관리 

운영체제는 각 계정을 관리할 수 있는 기능이 필요하다. 사용자 별로 프라이버시와 보안을 위해 개인 파일에 대해선 다른 사용자가 접근할 수 없도록 해야 한다. 이 밖에도 파일이나 시스템 자원에 접근 권한을 지정할 수 있도록 지원하는 것이 사용자 관리 기능이다.

- 계정 관리
- 접근권한 관리

###### 5. 디바이스 드라이버 

운영체제는 시스템의 자원, 하드웨어를 관리한다. 시스템에는 여러 하드웨어가 붙어있는데, 이들을 운영체제에서 인식하고 관리하게 만들어 응용 프로그램이 하드웨어를 사용할 수 있게 만들어야 한다.

따라서, 운영체제 안에 하드웨어를 추상화 해주는 계층이 필요하다. 이 계층이 바로 디바이스 드라이버라고 불린다. 

- 순차접근 장치
- 임의접근 장치
- 네트워크 장치

### 프로세스 & 스레드 

- 프로세스 
  - 프로그램을 메모리 상에서 실행중인 작업

- 스레드 
  - 프로세스 안에서 실행되는 여러 흐름 단위

###### 프로세스의 주소공간 할당 (독립적)

- **Code** : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- **Data** : 전역변수, 정적변수, 배열 등
  - 초기화 된 데이터는 data 영역에 저장
  - 초기화 되지 않은 데이터는 bss 영역에 저장
- **Heap** : 동적 할당 시 사용 (new(), malloc() 등)
- **Stack** : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)

###### 스레드의 주소공간 할당 

- Stack 만 독립적으로 할당 받으며, 나머지 영역은 공유한다. 

###### 멀티 프로세스 

- 여러 개의 CPU 를 사용하여 하나 이상의 프로세스들을 동시에 처리한다. 
- 메모리 침범 문제를 OS 차원에서 해결 가능하다. 
- 그러나 각각 독립된 메모리 영역을 가지고 있으므로, 작업량이 많을 수록 오버헤드가 발생한다. Context Switching 으로 인한 성능 저하

###### Context Switching 

- 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정 

- 즉, 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스 상태를 복구하는 과정을 말함

  → 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재함

###### 멀티 스레드 

- 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것

- 장점: 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소 전역 변수와 정적 변수에 대한 자료 공유 가능

- 단점: 안전성 문제. 하나의 스레드가 데이터 공간 망가뜨리면, 모든 스레드가 작동 불능 상태 (공유 메모리를 갖기 때문)

  - 멀티스레드의 안전성에 대한 단점은 Critical Section 기법을 통해 대비함
    - Mutual Exclusion 상호배제 
    - Progress 진행 => avoid deadlock 
    - Bounded Waiting 한정된 대기 => avoid starvation 

### 프로세스의 주소 공간 

프로그램이 CPU 에 의해 실행됨 => 프로세스가 생성되고 메모리에 프로세스 주소 공간이 할당됨 

- **코드 Segment** : 프로그램 소스 코드 저장
  - 프로그램 자체에서는 모두 같은 내용이기 때문에 따로 관리하여 공유 
- **데이터 Segment** : 전역 변수 저장
- **스택 Segment** : 함수, 지역 변수 저장
  - 함수와 지역변수는 LIFO 특성을 가진 스택에서 실행된다. 
  - 따라서 공통으로 사용하는 "전역 함수" 는 따로 지정해두면 메모리를 아낄 수 있다. => 데이터 Segment 에 저장 

### 인터럽트 

프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생된 상황에 대한 우선 처리가 필요함을 CPU에게 알리는 것.

외부/내부 인터럽트는 `CPU의 하드웨어 신호에 의해 발생`

소프트웨어 인터럽트는 `명령어의 수행에 의해 발생`

- 외부 인터럽트 : 입출력 장치, 타이밍 장치, 전원 등의 외부적 요인 

- 내부 인터럽트 (Trap) : 잘못된 명령이나 데이터를 사용할 때 발생, Exception 

- 소프트웨어 인터럽트 : 프로그램 처리 중 명령의 요청에 의해 발생한 것 

###### 인터럽트 발생 처리 과정 

현재 수행 중인 프로그램을 멈추고, 상태 레지스터와 PC 등을 스택에 잠시 저장한 뒤에 인터럽트 서비스 루틴으로 간다. (잠시 저장하는 이유는, 인터럽트 서비스 루틴이 끝난 뒤 다시 원래 작업으로 돌아와야 하기 때문)

만약 **인터럽트 기능이 없었다면**, 컨트롤러는 특정한 어떤 일을 할 시기를 알기 위해 계속 체크를 해야 한다. (이를 폴링(Polling)이라고 한다)

**폴링**을 하는 시간에는 원래 하던 일에 집중할 수가 없게 되어 많은 기능을 제대로 수행하지 못하는 단점이 있었다.

###### 폴링 vs 인터럽트 

폴링

- 사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 알아내는 방식
- 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다.

인터럽트 

- MCU 자체가 하드웨적으로 변화를 체크하여 변화 시에만 일정한 동작을 하는 방식

인터럽트 방식은 하드웨어로 지원을 받아야 하는 제약이 있지만, 폴링에 비해 신속하게 대응하는 것이 가능하다. 따라서 **실시간 대응**이 필요할 때는 필수적인 기능이다.

즉, 인터럽트는 **발생시기를 예측하기 힘든 경우에 컨트롤러가 가장 빠르게 대응할 수 있는 방법**이다.



### PCB & Context Switching

###### Process Management

How CPU manage Multiple Processes, by CPU scheduling 

Process Metadata 를 저장하는 PCB (Process Control Block) 를 통해 프로세스들을 구분한다. 

###### Process Metadata

- Process ID
- Process State
- Process Priority
- CPU Registers
- Owner
- CPU Usage
- Memeory Usage

###### PCB (Proces Control Block)

- 프로세스가 생성되면 프로세스 주소 공간에 stack, data, code 가 생성되고, 프로세스의 메타데이터가 저장된다. 
- 앞에서 살펴봤듯, interrupt 발생을 처리할 때, 현재 할당된 프로세스는 waiting 상태로 수행 대기 상태가 된다. 
  - 이 때, 이 대기 중인 (앞으로 수행할) 프로세스에 관한 저장 값을 저장해두어야 한다. => PCB 에 !   
- Linked List 구조로 관리되며, 삽입 삭제가 용이하다. 

###### Context Switching

CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정

- 수행 중인 프로세스를 변경할 때, CPU 의 레지스터 정보가 변경되는 것을 뜻한다.  
- 이 때 레지스터 값을 Context 라고 한다. 
- 발생하는 경우 
  - 인터럽트 
  - 실행 중인 CPU 사용 허가 시간 모두 소모 
  - 입출력을 위해 대기 

###### Overhead

어떤 처리를 하기 위해 들어가는 간접적인 처리 시간 · 메모리 등을 말한다.

Context Switching 때 해당 CPU 는 아무런 일도 하지 못하고, 이게 잦아지면 오버헤드가 발생한다. 

overhead 를 감수해야 하는 상황 

- 프로세스를 수행하다가 입출력 이벤트가 발생하여 대기 상태로 전환시키는 경우, CPU 는 다른 프로세스를 수행하는 것이 효율적이다.
- 즉 다른 프로세스를 실행시키기 위해 Context Switching 한다.  



### IPC (Inter Process Communication)

프로세스는 쓰레드와 다르게, 자원을 공유하지 않으므로 독립적으로 실행된다고 할 수 있다. 

이런 독립적 구조의 프로세스 간의 통신이 필요한 경우가 있으니, IPC 가 필요하며 이는 커널이 제공하는 IPC 설비에 의해 가능하다.

#### PIPE

파이프는 두 개의 프로세스를 연결하는데 

- 하나의 프로세스는 데이터를 쓰기만 하고, 
- 다른 하나는 데이터를 읽기만 할 수 있다.

**한쪽 방향으로만 통신이 가능한 반이중 통신**이라고도 부른다.

따라서 양쪽으로 모두 송/수신을 하고 싶으면 2개의 파이프를 만들어야 한다.

매우 간단하게 사용할 수 있는 장점이 있고, 단순한 데이터 흐름을 가질 땐 파이프를 사용하는 것이 효율적이다. 단점으로는 전이중 통신을 위해 2개를 만들어야 할 때는 구현이 복잡해지게 된다.

#### IPC types 

1. **익명 PIPE**

   익명 파이프는 통신할 프로세스를 명확히 알 수 있는 경우에 사용한다. (부모-자식 프로세스 간 통신처럼)

2. **Named PIPE (FIFO)**

   Named 파이프는 전혀 모르는 상태의 프로세스들 사이 통신에 사용한다.

   즉, 익명 프로세스의 확장된 형태로 부모 프로세스와 무관한 다른 프로세스와도 통신이 가능하다. 

3. **Message Queue** 

   메시지 큐는 파이프처럼 데이터의 흐름이 아니라 메모리 공간이다.

4. **공유 메모리 **

   파이프, 메시지 큐가 통신을 이용한 설비라면, **공유 메모리는 데이터 자체를 공유하도록 지원하는 설비**다.

   프로세스가 커널에 공유 메모리 할당을 요청하면, 커널이 메모리 공간을 할당하여 모든 프로세스가 해당 메모리 영역에 접근할 수 있게 된다. 이는 중개자가 없이 바로 메모리에 접근하므로 IPC 중에 가장 빠르다. 

5. **메모리 맵**

   공유 메모리처럼 메모리를 공유하지만, 메모리 맵은 열린 파일을 메모리에 맵핑시켜서 공유하는 방식이다. (즉 공유 매개체가 파일+메모리)

   주로 파일로 대용량 데이터를 공유해야 할 때 사용한다.

6. **소켓**

   네트워크 소켓 통신을 통해 데이터를 공유한다.

   클라이언트와 서버가 소켓을 통해서 통신하는 구조로, 원격에서 프로세스 간 데이터를 공유할 때 사용한다.

이러한 IPC 통신에서 프로세스 간 데이터를 동기화하고 보호하기 위해 **세마포어**와 **뮤텍스**를 사용한다. 





아래부터 이어서 ! 2022-06-02

https://gyoogle.dev/blog/computer-science/operating-system/IPC.html


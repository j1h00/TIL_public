# interview : technical practice01

## OS

- 프로세스가 뭔가요? 
  - 운영체제로부터 자원을 할당받아 실행되고 있는 동적인 상태의 프로그램

- 쓰레드가 뭔가요?
  - 프로세스 내에서 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위로, 다른 쓰레드와 자원을 공유할 수 있다.  
- 프로세스와 쓰레드의 차이 
  - 쓰레드는 프로세스를 구성하는 더 작은 실행 단위로, 
  - 프로세스는 메모리에 올라갈 때 운영체제로부터 독자적인 시스템 자원을 할당받는 반면, 
  - 쓰레드는 프로세스 내부에서 같은 프로세스 내 다른 쓰레드와 일정 메모리 영역을 공유한다. 



- 싱글 쓰레드의 장단점

  - 자원 접근에 대한 동기화를 신경쓰지 않아도 되며, context switching 작업을 요구하지 않는다. 
  - 그러나, 여러 개의 CPU 를 사용하지 못한다. 

  

- 멀티쓰레드의 장단점
  - 새로운 프로세스의 생성 보다, 기존 프로세스에서의 쓰레드 생성이 빠르다. 
  - 프로세스의 자원과 상태를 공유하므로 효율적인 운영이 가능하다. 
  - 프로세스의 context switching 보다 쓰레드의 작업 전환이 빠르다. 
  - 그러나, 운영체제의 지원과 쓰레드 스케쥴링이 필요하다. 



## Web 

- HTTP 가 뭔가요?
  - Hypertext transfer protocol 
  - W3 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약으로 주로 HTML 을 주고 받을 때 사용한다. 
  - 어플리케이션 계층의 프로토콜이다. 
- HTTP 의 특징
  - stateless 
    - 수신자가 이전 요청의 세션 상태를 유지해서는 안되는 통신 프로토콜
    - 발신자는 모든 요청을 개별적으로 이해할 수 있는 방식으로, 즉 수신자가 보유하고 있는 이전 요청의 세션 상태를 참조 하지 않는 방식으로 관련 세션 상태를 수신자에게 전달합니다.
  - Connectionless 
    - 클라이언트와 서버가 한 번 연결을 맺은 후, 클라이언트 요청에 대해 서버가 응답을 마치면 맺었던 연결을 끊어버리는 성질
    - 만약 서버에서 다수의 클라이언트와 연결을 계속 유지해야 한다면, 이에 따른 많은 리소스가 발생

- HTTPS?
  - 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
  - 공개키 암호화 방식으로 텍스트를 암호화한다. 

- HTTPS 통신 흐름

  1. 애플리케이션 서버(A)를 만드는 기업이 HTTPS 를 적용하기 위해 공개키와 개인키를 생성

  2. 신뢰할 수 있는 CA 기업을 선택하여 공개키 관리를 부탁하며 계약을 한다. 
  3. CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화하여 A서버에 제공한다. 
  4. A서버는 암호화된 인증서를 획득했다. 이제 A 서버는 공개키로 암호화된 HTTPS 요청이 아닌 다른 요청이 오면, 이 암호화된 인증서를 클라이언트에 건내준다. 
  5. 이 때 클라이언트는 CA 기업의 개인키로 암호화된 인증서를 받게 된다. 
  6. 브라우저는 이를 해독하여 A 서버의 공개키를 얻게 되고, 이제 A서버와 통신할 때는 얻은 공개키로 암호화한 요청을 날리게 된다. 

- 세션

  - HTTP 세션은 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때 까지의 기간이다. 
  - 서버는 클라이언트를 구분하기 위해 세션 ID 를 부여하여, 세션 ID 를 쿠키에 담아 클라이언트에 전송
  - 브라우저 종료시까지 인증 상태를 유지한다.   

- 쿠키

  - 클라이언트(브라우저) 로컬에 저장되는, 만료기한이 있는 키-값이 들어있는 작은 데이터 파일.

- CORS가 뭔가요?
  - Cross Origin Resource Sharing (교차 출처 공유)
  - 추가 HTTP 헤더를 사용하여, 한 출처(origin) 에서 실행 중인 웹 애플리케이션이 다른 출처(origin) 의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제입니다.
  - 웹 애플리케이션은 리소스가 자신의 출처(도메인, 프로토콜, 포트)와 다를 때 교차 출처 HTTP 요청을 실행합니다.

- CDN?
  - CDN(콘텐츠 전송 네트워크)은 **지리적으로 분산된 여러 개의 서버**입니다 **웹 콘텐츠를 사용자와 가까운 곳에서 전송함으로써 전송 속도를 높입니다**.
- REST
  - 즉, REST는 **HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처고,** REST API는 **REST를 기반으로 서비스 API를 구현한 것을 의미한다.**



## Front

- **E2E(End to End) 테스트**
  - 실제 사용자가 사용하는 것과 같은 조건에서 전체 시스템을 테스트
  - 단위/통합 테스트에 비해 작성이 어렵고 실행 속도가 비교적 느림
  - API 서버, DB 등의 외부 서비스들을 모두 사용하여 통합된 시스템을 테스트

- 웹팩

  - 최신 프론트엔드 프레임워크에서 많이 사용하는 모듈 번들러로, 
  - 모듈번들러란, 웹 어플리케이션을 구성하는 HTML, CSS, Javascript, image 파일 등을 모두 각각의 모듈로 보고, 이를 조합해서 병합된 하나의 결과물을 만드는 도구입니다. 

  - entry, output, loader, plugin

- 모듈 번들링

  - 파일들의 연관된 관계와 의존도를 파악하여, 하나의 파일로 병합 및 압축시켜주는 과정 
  - 해당 파일을 하나로 묶으므로 적은 HTTP 요청으로도 자원을 불러올 수 있다. 

-  바벨

  - JS 에서 지원하는 최신 문법들을 최대한 많은 브라우저 환경에서 호환이 가능하도록 변환(Transpile)
  - ex) ES6 이후의 문법을 브라우저에서 범용적으로 사용되는 문법으로 변환 



- `DOCTYPE` 
  - HTML이 어떤 버전으로 작성되었는지 미리 선언해, 웹브라우저가 내용을 올바로 표시할 수 있도록 해주는 것입니다.
- meta 태그 
  - HTML 문서가 어떤 내용을 담고 있고, 키워드는 무엇이며, 누가 만들었는지에 대한 정보를 담고있는 태그이다.
- semantic 태그 
  - 서로 관계가 있는 정보를 파악하고 콘텐츠가 어떤 맥락 안에 있는지 알기 쉽다.
  - 검색엔진을 통해 검색이 잘 될 수 있도록 돕는다.

- 검색엔진 최적화 
  - 웹 페이지 검색엔진이 자료를 수집하고 순위를 매기는 방식에 맞게 웹 페이지를 구성해서 검색 결과의 상위에 나올 수 있게 한다
- 반응형 웹의 3요소 
  - 그리드 레이아웃
  - 가변형 이미지
  - 미디어 쿼리

- `CSS-in-JS`
  - CSS-in-JS는 CSS 모델을 문서 레벨이 아니라 컴포넌트 레벨로 추상화 한다.(모듈성)
  - 자바스크립트와 CSS 사이의 상수와 함수를 공유
  - 현재 사용 중인 스타일만 DOM에 포함

- DOM
  - HTML 문서의 계층적 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조다.
- 브라우저의 동작 원리
  1. HTML 마크업을 처리하고 DOM 트리를 빌드한다. (**"무엇을"** 그릴지 결정한다.)
  2. CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. (**"어떻게"** 그릴지 결정한다.)
  3. DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. (**"화면에 그려질 것만"** 결정)
  4. 렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. (**"Box-Model"** 을 생성한다.)
  5. 개별 노드를 화면에 페인트한다.(or 래스터화)



### Javascript

변수를 선언할 때는 `var`, `let`, `const` 키워드를 이용하며, 뒤에 오는 변수 이름으로 새로운 변수를 선언한다. 

변수 선언에 의해 확보된 메모리 공간은 자바스크립트 엔진에 의해 암묵적으로 undefined 라는 값이 할당되어 초기화된다. 

#### 변수 / 객체

- 호이스팅
  - 자바스크립트는 변수 선언이 소스 코드의 어디에 있든 상관 없이 다른 코드보다 먼저 실행한다. 
  - 런타임 이전에 실행 컨텍스트에 의해 스코프에 등록되고, 변수가 어디에 위치하던지 상관 없이 변수를 참조할 수 있는 것처럼 만드는 특징을 말합니다. 

- `var` 의 특징
  - 변수 중복 선언 가능 
  - 함수 레벨 스코프 
  - 변수 호이스팅 
- `let` 의 특징 (ES6에 처음 도입)
  - 변수 중복 선언이 금지
  - 블록 레벨 스코프 
  - 변수 호이스팅 
    - `let`으로 선언한 변수는 `선언` 과 `초기화` 단계가 분리되어 진행되며, 변수 선언문에 도달했을 때 초기화 단계가 실행된다. 따라서 초기화 단계 이전에 변수에 접근하면 참조 에러가 발생합니다. 
    - TDZ (Temporal Dead Zone) : 스코프의 시작 지점부터 변수 선언문(초기화 단계 시작 시점) 까지, 변수를 참조할 수 없는 구간 
  - `let` 으로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다 
- `const` 의 특징 
  - 선언과 동시에 초기화 해야 한다. 
  - 재할당 금지
    - 따라서 원시 값이 변경 불가능하므로 상수 표현에 사용한다. 
- 정적 타이핑
  - 변수 선언 시, 데이터 타입을 사전에 선언해야 하는 것을 명시적 선언이라 한다. 
  - 정적 타입 언어는 변수의 타입을 변경할 수 없고, 타입에 맞는 값만 할당할 수 있다. 
  - 반면, 자바스크립트는 동적 타이핑으로 변수의 타입이 재할당에 의해 언제든 바뀔 수 있다. 
- 고차함수 
  - 함수를 인수로 전달받거나 반환하는 함수를 말함.
  - 자바스크립트의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달하고 반환할 수 있다. 

- 객체 
  - 원시값을 제외한 나머지 값(함수, 배열 등) 이 모두 객체이며, 원시 타입이 단 하나의 값만 나타내지만 객체 타입은 다양한 타입의 값을 하나의 단위로 구성한 복합 자료구조이다. 
  - 객체는 프로퍼티로 구성되며, 프로퍼티는 키와 값으로 구성된다. 
- 메서드 
  - 프로퍼티의 값이 함수일 경우 일반 함수와 구분하여 메서드라 부른다. 

- call by value
  - 변수에 원시 값을 갖는 변수를 할당하면, 윈시 값이 복사되어 전달된다. 
- call by reference
  - 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. 
  - 객체의 프로퍼티는 추가적으로 추가 삭제되는데, 따라서 객체는 메모리 공간의 크기를 사전에 정해둘 수 없가. 이러한 가변성 때문에 객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하여 참조 값에 접근할 수 있다. 

#### 함수 

- 함수 정의 방법

  - 함수 선언문 
  - 함수 표현식
  - Function 생성자 함수
  - 화살표 함수  

  ```js
  case 1 :함수 선언문
  
  function add(x,y){
    return x+y;
  }
  
  case 2: 함수 표현식
  var add = function(x,y){
    return x + y;
  }
  
  case 3: Function 생성자 함수
  var add = new Function('x','y', 'return x+y');
  
  case 4: 화살표 함수(ES6)
  var add = (x,y) => x+y;
  ```

  - 함수 선언문 작성시, 함수 호이스팅에 의해 선언과 할당까지 완료된 상태로, 함수 선언문 이전에 참조와 호출이 가능하다. 

- 스코프 

  - 식별자(변수)가 유효한 범위 
  - 렉시컬 스코프
    - 함수의 호출 위치가 아니라, 정의한 위치에 따라 함수의 상위 스코프를 결정한다. 

- 전역 변수 

  - 암묵적 결합
  - 변수의 긴 생명주기
  - 스코프 체인 상에서 종점에 존재
  - 네임스페이스 오염

- 생성자 함수 

  - 생성자 함수란 new 연산자와 함께 호출하여 객체를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스라고 한다.
  - 객체를 생성하기 위한 템플릿처럼 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.

- 일급 객체 

  1. 무명의 리터럴로 생성할 수 있다. (함수 이름 없이)
  2. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
  3. 함수의 매개변수에 전달할 수 있다.
  4. 함수의 반환 값으로 사용할 수 있다.

  - 함수형 프로그래밍을 가능하게 한다. 

    - **순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 프로그래밍 패러다임**

    - 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 순수 함수라 한다.

- this

  - this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.

  - 단 this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

| 함수 호출 방식                                             | this 바인딩                                                  |
| ---------------------------------------------------------- | ------------------------------------------------------------ |
| 일반 함수 호출                                             | 전역 객체(window/ global)                                    |
| 콜백 함수 호출                                             | 전역 객체(window/ global)                                    |
| 내부 함수 호출                                             | 전역 객체(window/ global)                                    |
| 메서드 호출                                                | 메서드를 호출한 객체                                         |
| 생성자 함수 호출                                           | 생성자 함수가 (미래에) 생성할 인스턴스                       |
| Function.prototype.apply/call/bind 메서드에 의한 간접 호출 | Function.prototype.apply/call/bind 메서드에 첫 번째 인수로 전달한 객체 |



- 실행 컨텐스트 

  - **실행 컨텍스트는 ① 실행 컨텍스트 스택과 ② 렉시컬 환경으로 구성되어 있다.**

  **① 실행 컨텍스트 스택은** 코드의 실행 순서를 관리하는 자료구조로, L.I.F.O(Last In First Out) 구조로 들어오는 코드를 관리한다.

  **② 렉시컬 환경은** 모든 식별자와 바인딩된 값, 스코프를 기록 및 관리하는 자료구조이다.

- 클로저 

  - 클로저는 자신이 선언될 당시의 환경을 기억하는 함수
  - 해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도 (실행 컨텍스트 스택에서 푸시되더라도) 렉시컬 환경에 남아 참조가 가능하다
  - 장점
    - 클로저는 **상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.**
    - 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 **은닉(information hiding)하고 특정 함수에게만 상태변경을 허용하기 위해 사용한다.**

  ```js
  var name = `Global`;
  function outer() {
    var name = `closure`;
    return function inner() {
      console.log(name);
    };
  }
  
  var callFunc = outer();
  callFunc(); // => 'closure' !!! not 'Global'
  ```

  - 이처럼 외부 함수 호출이 종료되더라도 외부 함수의 지역 변수 및 변수 스코프 객체의 체인 관계를 유지할 수 있는 구조를 `클로저` 라고 한다.



- 디바운스에 대해서 알고 있나요?
  - 디바운스(debounce)는 짧은 시간 간격으로 이벤트가 연속해서 발생하면 이벤트 핸들러를 호출(call)하지 않다가 **일정 시간이 경과된 이후에 이벤트 핸들러가 한 번만 호출되도록 한다.**
  - 즉 디바운스는 **짧은 시간 간격으로 발생하는 이벤트를 그룹화해서 마지막에 한 번만 이벤트 핸들러가 호출되도록 한다.**

#### 비동기

- 비동기 프로그래밍

1. 현재 실행 중인 태스크가 **종료될 때까지 다음에 실행될 태스크가 대기하는 방식** 을 동기(synchronous) 처리 방식이라고 하며
2. 현재 실행 중인 태스크가 **종료되지 않은 상태라 해도 다음 태스크를 곧바로 실행하는 방식** 을 비동기(asynchronous) 처리라고 한다.
3. 대표적으로 타이머 함수인 **① setTimeout/ setInterval ② HTTP 요청 ③ 이벤트 핸들러** 는 비동기 처리 방식으로 동작한다.식

- 이벤트 루프와 테스크 큐 

  - 자바스크립트는 싱글 스레드로 동작하기 때문에 한 번에 하나의 태스크만 처리할 수 있다.  하지만 브라우저가 동작하는 것을 살펴보면 많은 태스크가 동시에 처리되는 것처럼 느껴진다
  - **이처럼 자바스크립트의 동시성을 지원하는 것이 바로 이벤트 루프(event loop)다.**

- 자바스크립트 엔진은 크게 `(1) 콜 스택(call stack)` 과 `(2) 힙(heap)` 이라는 2개의 영역으로 나눈다.

  1. 콜 스택

     - 소스코드(전역 코드 및 함수 코드 등) 평가 과정에서 생성된 실행 컨텍스트가 추가되고 제거되는 스택 자료구조

     - 자바스크립트 엔진은 단 하나의 콜 스택을 가진다

  2. 힙
     - 객체가 저장되는 메모리 공간이다. 콜 스택의 요소인 실행 컨텍스트는 힙에 저장된 객체를 참조한다.
     - 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당)해야 한다. 따라서 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않다

- 예를 들어,

  1. 비동기 방식으로 동작하는 setTimeout의 콜백 함수의 평가와 실행은 자바스크립트 엔진이 담당하지만

  2. 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저 또는 Node.js가 담당한다

     이를 위해 브라우저 환경은 태스크 큐와 이벤트 루프를 제공한다

  3. 태스크 큐 (task queue/event queue/callback queue)
     - setTimeout이나 setInterval과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다
  4. 이벤트 루프 
     - 이벤트 루프는 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인한다
     - 만약 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(FIFO)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킨다
     - 이때 콜 스택으로 이동한 함수는 실행된다. 즉, 태스크 큐에 일시 보관된 함수들을 비동기 처리 방식으로 동작한다



- Ajax(Asynchronous JavaScript and XML)가 뭔가요 어떤 것을 담당하고 있죠?
  - 자바스크립트를 사용하여 ① 브라우저가 ② 서버에게 비동기 방식으로 데이터를 요청하고, 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식 을 말한다.
  - Ajax는 브라우저에서 제공하는 호스트 객체 Web API인 XMLHttpRequest 객체를 기반으로 동작한다.
  - Ajax의 등장으로 서버로부터 웹페이지의 변경에 필요한 데이터만 비동기 방식으로 전송받아 웹페이지를 변경할 필요가 없는 부분까지 다시 렌더링하지 않고, 변경할 필요가 있는 부분만 한정적으로 렌더링하는 방식이 가능해졌다.



- 콜백
  - 자바스크립트에서 콜백 함수는 다른 함수의 매개변수로 함수를 전달하고, 어떠한 이벤트가 발생한 후 매개변수로 전달한 함수가 다시 호출되는 것을 의미합니다.
  - 어떤 일을 다른 객체에게 시키고, 그일이 끝나는 것을 기다리지 않고 끝나고 부를 때까지 다른 일을 하는 것을 말합니다. 이 때문에 `동기`가 아닌 `비동기`적으로 처리되는 비동기 방식의 함수라고 할 수 있습니다.

- 프로미스 
  - 전통적인  콜백 패턴은 일명 '콜백 헬'로 인해 가독성이 나쁘고 비동기 처리 중 발생한 에러의 처리가 곤란하며 여러 개의 비동기 처리를 한 번에 처리하는데 한계를 느꼈다.
  - Promise 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리를 수행한다. 이때 비동기 처리가 성공하면 resolve를, 실패하면 reject를 호출한다.

- 제너레이터

  - ES6에서 도입된 제너레이터(generator)는 `① yield 키워드와 ② next 메서드를 통해` 코드 블록의 실행을 일시 중지 (블로킹) 했다가 필요한 시점에 재개할 수 있는 특수한 함수다.

  1. 제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
  2. 제너레이터 함수는 함수 호출자와 함수의 상태를 주고받을 수 있다.
  3. 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.

- async / await 

  - ES8에서는 제너레이터보다 간단하고 가독성 좋게 `비동기 처리를 동기 처리처럼 동작하도록 구현할 수 있는` async/await가 도입되었다.

  - `프로미스를 기반으로 동작`하며, 프로미스의 후속 처리 메서드 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다.

  - async

    - 언제나 프로미스를 반환한다.

      async 함수가 명시적으로 프로미스를 반환하지 않더라도 async 함수는 암묵적으로 반환 값을 resolve하는 프로미스를 반환한다.

  - await 

    - await 키워드는 프로미스가 **settled 상태(비동기 처리가 수행된 상태)** 가 될 때까지 대기하다가 settled 상태가 되면 프로미스가 resolve한 처리 결과를 반환한다.

  

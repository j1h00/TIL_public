# interview questions

##  프론트엔드 직무 면접 질문 정리 

>[프론트엔드 개발자 면접 정리](https://velog.io/@suyeonme/%ED%9B%84%EA%B8%B0-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%EC%A0%95%EB%A6%AC)
>
>[프론트엔드 면접 준비 하시는 분...?](https://velog.io/@junh0328/%ED%94%84%EB%A1%A0%ED%8A%B8-%EC%97%94%EB%93%9C-%EB%A9%B4%EC%A0%91-%EC%A4%80%EB%B9%84-%ED%95%98%EC%8B%A4%EB%B6%84)



### OS

- 프로세스가 뭔가요?
  - 컴퓨터에서 실행되고 있는 프로그램
  - 운영체제로부터 자원을 할당받은 작업의 단위 
  - 컴퓨터 메모리에 올라가 있는 동적인 상태의 프로그램

- 스레드가 뭔가요?
  - 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위 

- 프로세스와 스레드는 어떤 차이가 있나요?
  - 스레드는 프로세스를 구성하는 더 작은 실행 단위의 개념으로, 
    - 프로세스는 메모리에 올라갈 때 운영체제로부터 독자적인 시스템 자원을 할당 받는 반면, 
    - 스레드는 프로세스 내부에서 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유한다. 




- 싱글 스레드 장점
  - 자원 접근에 대한 동기화를 신경쓰지 않아도 된다. 
  - context switching 작업을 요구하지 않는다. 

- 싱글 스레드 단점
  - 여러 개의 CPU 를 활용하지 못한다. 

- 멀티 스레드 장점
  - 새로운 프로세스 생성보다는, 기존 프로세스에서 스레드 생성이 빠르다. 
  - 프로세스의 자원과 상태를 공유하여 효율적인 운영이 가능 
  - 프로세스의 작업전환보다 스레드의 작업전환이 빠름 

- 멀티 스레드 단점
  - 운영체제의 지원이 필요, 스레드 스케줄링






### Web etc

- HTTP ?

  - HypterText Transfer Protocol
  - 인터넷 상에서 클라이언트와 서버가 자원(데이터)을 주고 받을 때 쓰는 통신 규약

- HTTPS ?

  - 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
  - HTTPS는 텍스트를 암호화한다. (공개키 암호화 방식으로)

- HTTPS 통신 흐름 

  1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.

  2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.
     - CA (Certificate Authority) : 공개키를 저장해주는 신뢰성이 검증된 민간기업 

  3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.

  4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.
  5. 클라이언트는 `main.html` 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.
  6. 브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다. 이제 A서버와 통신할 대는 얻은 A서버의 공개키로 암호화해서 요청을 날리게 된다.

  

- HTTP 프로토콜의 가장 큰 특징은 뭔가요?

  - stateless
    - 데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다.
    - TCP/IP 통신 위에서 동작하며 기본 포트는 80번이다.  

- URL은 뭔가요?

  - Uniform Resource Locators 
  - 서버에 자원을 요청하기 위해 입력하는 영문 주소. 숫자로 되어 있는 IP 주소보다 기억하기 쉽다.

  - 브라우저는 URL HTTP 요청을 DNS(Domain Name System) 을 통해 host 에 해당하는 실제 IP 주소로 변환하여 서버에 요청

  

- HTTP/1.1 과 HTTP/2.0의 차이는 뭔가요?

  - HTTP/1.0 은 기본적으로 한 연결당 하나의 요청을 처리하도록 설계되어, 서버로부터 리소스 요청과 응답이 개별적으로 전송되어, TCP 의 3-way-handshake 를 계속해서 열게되고, RTT 가 증가하는 단점이 있다. 

  - HTTP/1.1 은 매번 TCP 연결을 하지 않고, 한 번 TCP 초기화 이후에 여러 개의 파일을 송수신 하는 keep-alive 옵션이 표준화되어 기본 옵션으로 설정되었다. 그러나 마찬가지로 동시 전송은 안되므로, 요청하는 리소스 개수에 비례해서 응답 시간도 증가한다. 

  - HTTP/2.0 은 커넥션 당 여러 개의 요청과 응답이 가능하다. 즉 다중 요청/응답이 가능하다. 

    - 멀티플렉싱, 헤더 압축, 서버 푸시, 요청 우선순위 처리를 지원 

      

- HTTPS는 HTTP랑 뭐가 다른가요?

  - 애플리케이션 계층과 전송 계층 사이에 신뢰 계층인 SSL/TLS 계층을 넣은 신뢰할 수 있는 HTTP 요청을 말한다. 이를 통해 통신을 암호화한다. 
  - 클라이언트 서버 통신 시, 제 3자가 메시리를 도청하거나 변조하지 못하도록 한다. 
  - 보안 세션을 기반으로 데이터를 암호화하며, 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘을 사용



- 심화) 공개키 (비대칭키) 방식이 뭔가요?
  - 인증 메커니즘은 CA(Certificate Authorities) 에서 발급한 인증서를 기반으로, 클라이언트에 공개키를 제공하고, 사용자가 접속한 서버가 신뢰할 수 있는 서버임을 보장한다. 
  - 클라이언트와 서버 모두가 개인키와 공개키를 생성하면 이를 결합하여, 암호화 알고리즘에 의해 PSK(Pre-Shared Key) 를 생헝한다. 



- 쿠키, 세션을 왜 쓰나요?

  - HTTP 프로토콜의 특성이자 약점을 보완하기 위해서 쿠키 또는 세션을 사용합니다.

    기본적으로 HTTP 프로토콜 환경은 "connectionless, stateless"한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야합니다. 이 특성을 보완하기 위해서 쿠키와 세션을 사용하게됩니다.

- 쿠키가 뭔가요?

  - 클라이언트(브라우저) 로컬에 저장되는, 만료기한이 있는 키-값이 들어있는 작은 데이터 파일.
  - `document.cookie` 로 쿠키를 볼 수 없게 `httponly` 옵션을 거는 것이 중요하며, 4KB 까지 저장 가능하다. 
  - 동작순서 
    - 클라이언트가 페이지를 요청하면, 웹 서버는 쿠키를 생성
    - 생성한 쿠키에 정보를 담아 클라이언트에게 HTTP 화면을 돌려줄 때, 같이 돌려준다.
    - 클라이언트는 넘겨 받은 쿠키를 저장하고, 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다. 
    - 동일 사이트 재방문 시 클라이언트의 PC 에 해당 쿠키가 있는 경우, 요청과 함께 쿠키를 전송

  - 브라우저에 저장되므로 보안에 약할 수 있다. 

  

- 세션이 뭔가요?

  - HTTP 세션은 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때 까지의 기간이다. 
  - 세션 스토리지는 만료 기한이 없는 키-값 저장소이며, 탭 단위로 세션 스토리지를 생성하며 탭을 닫을 때 해당 데이터가 삭제된다. 5MB 까지 저장이 가능하다. 
  - 서버에 세션 객체를 생성하며, 각 클라이언트마다 고유한 세션 ID 값을 부여한다. 
  - 쿠키를 사용하여 세션 ID 값을 클라이언트에 보내고, 웹 브라우저가 종료되면 세션 쿠키는 삭제된다. 
  - 동작순서 
    - 클라이언트 페이지가 요청 
    - 서버가 클라이언트마다 개별적인 세션 ID 를 부여
    - 클라이언트는 요청할 때마다 세션 ID 를 서버에 전달
    - 서버는 받은 세션 ID 로 클라이언트 정보를 가져와 활용

- 쿠키와 세션의 차이는 어떤 점이 있을까요?

  - 저장위치 => 클라이언트 / 서버 

  - 보안

    - 쿠키는 브라우저 로컬에 저장되기 때문에 변질되거나, 요청 시 갈취당할 수 있어 보안에 취약 / 
    - 세션은 쿠키를 이용해서 세션 id 만 저장하고, 그것으로 구분해서 서버에서 처리하기 때문에 비교적 안전

  - life cycle

    - 쿠키는 만료 시간은 있지만, 파일로 저장되기 때문에 브라우저를 종료해도 정보가 남아있다. 
    - 세션은 만료 기간을 정할 수는 있지만, 브라우저가 종료되면 그에 상관없이 삭제된다. 

  - 속도 

    - 쿠키는 정보를 포함하기 때문에 서버에 요청시 속도가 빠르다. 
    - 세션은 정보는 서버에 있기 때문에, 처리가 요구되어 비교적으로 느리다. 

    

- CORS가 뭔가요?
  - Cross Origin Resource Sharing (교차 출처 공유)
    - Origin 은 프로토콜, 호스트 이름, 포트의 조합을 말한다. 
      - 즉, scheme, host, port 로 이루어진 도메인을 의미한다. 

  - 서버가 웹 브라우저에서 리소스를 로드할 때, 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
    1. 현재 자신이 속한 출처(Origin) 을 기준으로 다른 출처(Origin) 에 API 를 요청하게 되면 브라우저에서 이 요청으로 넘어오는 경과가 안전한지 판단하게 된다. 
    2. 응답을 보내는 출처가 자신이 속한 출처가 아닌, 다른 출처여도 서로 예상되는 출처라면, 요청에 대해 허용해주는 응답 헤더를 보내, 브라우저가 결과를 보여준다.  
  - Origin이 다른 http 통신에서는 request header에 쿠키가 자동으로 들어가지 않기 때문에 서버에게 또는 클라이언트에게 내가 어떤 요청을 보내는 지 알려줘야 하낟. 




- 웹팩이란?

  - 최신 프론트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러(Module Bundler)
    - 모듈 번들러는, 웹 어플리케이션을 구성하는 자원 (HTML, CSS, JavaScript, Images 등) 을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구이다. 

- 모듈이란?

  - 프로그래밍 관점에서, 특정 기능을 갖는 작은 코드 단위 (성격이 비슷한 기능들을 하나의 의미있는 파일로 관리하면 모듈이 된다.)

- 모듈 번들링이란?

  - 웹 어플리케이션 구성 자원들을 하나의 파일로 병합 및 압축해주는 동작 
  - 파일들의 연관된 관계를 파악하여, 파일들을 하나의 파일로 압축시켜주는 과정

- 웹팩이 등장한 이유 웹팩 사용 시에 이점

  - 웹 개발 작업 자동화 도구 

    1. 개발 시, 텍스트 편집기에서 코드 수정 후 새로고침 
    2. 배포 시, HTML, CSS, JS 압축, 이미지 압축, CSS 전처리기 변환 

  - 웹 어플리케이션의 빠른 로딩 속도와 높은 성능 

    - 모듈 번들링을 통해, 해당 파일을 하나로 묶으므로 적은 HTTP 요청으로도 자원을 불러올 수 있다. 

       

- 바벨이란?

  - Javascript 에서 지원하는 최신 문법들을 최대한 많은 브라우저 환경에서 호환이 가능하도록 변환(Transpile)해주는 언어 

  - 트랜스파일: 한 언어로 작성된 소스 코드를 비슷한 수준의 추상화를 가진 다른 언어로 변환 

  - ex) ES6 이후의 문법을 브라우저에서 범용적으로 사용되는 문법으로 변환 

    `() => {}` => `function () {}`

- 웹팩의 주요 속성 4가지

  - entry: 최초 진입점이자, 빌드를 할 대상 파일의 위치 
  - output: 결과물의 파일 경로와 이름 지정 
  - loader: Javascript 이외의 웹 자원(HTML, CSS, images, fonts) 을 output 에 포함될 수 있도록 도와주는 속성 
  - plugin: 결과물의 형태를 바꾸는 역할




### HTML / CSS 

- DOCTYPE에 대하여 설명하시오
- 쿼크 모드, 표준 모드를 사용해야 하는 이유
- 쿼크모드가 무엇일까요?
- 표준모드란 무엇일까요?



### Javascript 

- Function 키워드로 사용하는 일반 함수와 화살표 함수의 차이점은 무엇인가요?



### TypeScript

- Why?
  - 정적 타이핑을 지원, 타입을 지정하고 먼저 타입을 선언함으로써, 프로그래밍 단계와 HTTP 통신을 통해 데이터를 주고 받는 과정에서 생기는 데이터를 안전하게 주고 받을 수 있다. 
  - 타입에 관련된 프로토타입 메서드도 손쉽게 찾아 쓸 수 있다. 

- Type 과 Interface 의 차이 
  - `&` vs `extends` 키워드를 통한 확장
  -  인터페이스는 동일한 이름으로 재정의할 시, 선언적 확장이 가능하다. 

### React 

- 프레임워크 vs 라이브러리 
  - 프레임워크는 Application 개발 시, 코드의 품질, 필수적인 코드, 알고리즘, 암호화, 데이터베이스 연동 등의 기능들이 어느 정도 구성되어 있는 뼈대(구조)를 제공
  - 라이브러리는 특정 기능에 대한 API (도구 / 함수)를 모은 집합 
  - 라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어하고, 동작하는 중에 필요한 기능이 있을 때 능동적으로 라이브러리를 사용할 뿐이다. 반면에 프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용되어, 프레임워크가 짜놓은 틀에서 수동적으로 동작해야 한다. 
- React 의 특징
  1. 컴포넌트 기반의 화면 구성 
  2. Virtual DOM 으로 인한 충분히 빠른 속도 
     - UI  의 이상적인 또는 가상적인 표현을 메모리에 저장하고, ReactDOm 과 같은 라이브러리에 의해 실제 DOM 과 동기화하는 프로그래밍 개념
  3. SPA
     - 서버의 자원을 아끼고, 더 좋은 사용자 경험을 주지만
     - 사용자와 인터렉션이 많은 경우에는 서버의 자원이 많이 사용되고 불필요한 트래픽이 낭비된다. 
- React 의 장점
  - component 를 사용하여 유지 보수가 용이하고, 최적화된 렌더링이 가능 
  - 생태계가 넓고 다양한 라이브러리 사용 가능 
  - virtual DOM 을 이용한 빠른 렌더링
  - 리액트 네이티브 

- 함수 컴포넌트 vs 클래스 컴포넌트 

  - 클래스 컴포넌트 
    - 객체 지향 프로그래밍의 구조를 띄고, state 를 초기화하기 위해선 생성자 함수를 필요로 한다. 
    - 함수 컴포넌트에 비해 코드가 길어지고 사이즈가 커진다.
    - state 기능 및 라이프 사이클 기능을 사용할 수 있고, 임의 메서드를 정의할 수 있다. 
    - render 함수가 꼭 있어야 한다. 

  -  함수 컴포넌트 
    - hooks 를 사용하여 생성자 함수 필요 없다. 
    - 선언하기 좀 더 편하고, 메모리 자원을 덜 사용한다. 
    - 빌드 시에도, 결과물의 파일 크기가 더 작다. 
    - hooks 를 이용해 라이프사이클 API 사용이 가능해졌다. 
    - 사이드 이펙트를 빈번히 일으키기 때문에, 순수 함수를 지향하는 함수형 프로그래밍과 차이가 있다. 

- state 의 불변성
  - 객체는 실제 데이터 값이 아닌 참조 값을 가지므로, 객체가 복사되어 동일한 참조 값을 가지는 여러 객체 중 하나라도 변경된다면, 모든 객체의 내부 값이 변경된다. 
  - 따라서 객체 혹은 배열 형식의 데이터를 다룰 때, 원본 배열이 변경되는 경우 의도한 동작과 다르게 동작하거나, side effect 가 발생하는 것을 막고자 불변성을 유지해야 한다.  

- 라이프 사이클 

  ![undefined](https://cdn.filestackcontent.com/ApNH7030SAG1wAycdj3H)

  1. 마운트 
     - DOM 이 생성되고 웹 브라우저 상에 나타나는 것 
  2. 업데이트 
     - props 가 바뀔 때 
     - state 가 바뀔 때 
     - 부모 컴포넌트가 업데이트 될 때 
     - `forceUpdate()` 로 강제로 렌더링을 트리거할 때 

  3. 언마운트 
     - 컴포넌트를 DOM 에서 제거하는 것 

- Hooks 의 종류 

  - v 16.8 에 도입된 기능으로, 기존 함수 컴포넌트에서 사용할 수 없었던 다양한 작업 가능

  1. `useState`

     - setState 함수에 파라미터를 넣어 호출하면, 전달받은 파라미터로 상태가 바뀌고 컴포넌트가 리렌더링 된다. 

  2. `useEffect`

     - 리액트 컴포넌트가 렌더링될 때마다 특정 작업을 수행

  3. `useReducer`

     - useState 보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트하고 싶을 때, 
     - 현재 상태, 업데이트를 위해 필요한 정보를 담은 액션 겂을 전달받아 새로운 상태에 반환하는 함수 

  4. `useMemo `

     - 함수 컴포넌트 내부에서 발생하는 연산을 최적화

     - 예를 들어, 숫자를 입력하면 평균을 계산하는 `getAverage` 함수가 있다고 하면, 

       - input 내용이 수정될 때마다 getAverage 함수가 호출되어, 렌더링할 때마다 계산을 하게 되어 비효율적이다. 

       ```javascript
       const avg = useMemo(() => getAverage(list), [list]);
       ```

  5. `useCallback `

     - useMemo 와 비슷
     - 렌더링 성능 최적화 상황에서 사용하며, 만들어뒀던 함수를 재사용할 수 있다. 
     - 첫 번 째 파라미터에는 생성하고 싶은 함수, 두 번 째 파라미터에 배열을 넣으며, 어떤 값이 배뀌었을 때 함수를 새로 생성해야 하는지 명시한다. 

  6. `useRef `
     - DOM 조작을 위해 사용
     - `.current` 속성에 변경 가능한 값을 담고 있는 객체이다. 

- `useCallback` vs `useMemo`
  - 메모이제이션된 함수 vs 값 반환 

- 리액트에서 `setState`는 비동기 동작인가요, 동기동작인가요?
  - 비동기 동작
  - 한 컴포넌트 안에서 여러 state 값을 연속으로 바꿔준다면, 여러 번 비교하고 다시 그리는 비효율적인 일이 발생한다. 
  - 따라서 `setState` 가 비동기 함수로 동작하여 컴포넌트 내의 비동기 함수를 처리하는 콜백큐가 다 비워지면 리렌더링하도록 설계하였다. 
    - 즉, 해당 함수 내에서 동깆거으로 실행되는 함수가 모두 실행된 뒤에 마지막에 setState 를 처리한다. 


- `useLayoutEffect`
  - `useEffect` 는 브라우저가 스크린에 페인팅 작업을 완료한 뒤에 실행된다. 
    - 즉, `useState(0)` 과 같은 초기 useState 의 값이 빈 값이라면, 0 을 출력했다가 `useEffect` 에 의해 값이 채워지는 구조를 가진다. 
  - `useLayoutEffect` 는 이런 문제를 해결하기 위해, 브라우저가 화면에 DOM 을 그리기 전에 이펙트를 수행한다. 
- 리액트의 성능 개선 방법
  - hook 함수 사용
  - 코드 스플리팅 (react.lazy(), Next.js 프레임워크)





- 의존성 배열은 shallow equal, deep equal중 무엇을 하게 되나요?

- props로 전달받은 함수는, props나 상태가 업데이트될 때마다 새로 생성이 됩니다. 이 때 최적화할 수 있는 방법은 어떤게 있나요?

- 다이나믹한 데이터를 받아올 때, useEffect에서 의존성배열을 어떻게 하실건가요?
- React의 hook에 대해서 설명해주세요.
- 주로 어떤 경우에 custom hook을 사용했고, 그로 인해서 얻은 장점이 무엇인가요?
- Styled-components의 퍼포먼스에 대한 이슈에 대해서 경험해보신 적이 있나요?
- 함수형 프로그래밍의 장점은 무엇인가요? (테스트 코드와 연관)
- 최근 진행했던 프로젝트중 어려웠던 부분은, 그리고 어떻게 해결했나요?



### Next.js

- CSR와 SSR의 차이점은?
  - SSR 
    - 요즘 웹에서 제공되는 정보가 워낙 많다. 요청할 때마다 새로고침이 일어나면서 페이지를 로딩할 때마다 서버로부터 리소스를 전달받아 해석하고, 화면에 렌더링하는 방식인 SSR은 데이터가 많을 수록 성능문제가 발생했다.
    - 이는, 인터랙션이 많은 환경에서 비효율적이다. 렌더링을 서버쪽에서 진행하면 그만큼 서버 자원이 많이 사용되기 때문에 불필요한 트래픽이 낭비된다.
    - 장점 
      - 검색엔진 최적화 
      - 초기 로딩 성능 개선 (첫 렌더링된 HTML 을 클라이언트에게 선달하기 때문에)

  - CSR 
    - CSR 방식은 사용자의 행동에 따라 필요한 부분만 다시 읽어온다. 따라서 서버 측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있다. 서버는 단지 JSON파일만 보내주고, HTML을 그리는 역할은 자바스크립트를 통해 클라이언트 측에서 수행하는 방식이다.
    - 장점 
      - 트래픽 감소, 필요한 데이터만 받는다. 
      - 사용자 경험 

    - 단점
      - 검색 엔진 최적화 
- Next.js에서 `getStaticProps`, `getServerSideProps`의 차이점은?




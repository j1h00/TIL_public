# Knapsack 완전 이해하기 

SSAFY_JAVA_track / 2021-10-16_algorithm01_knapsack 참고 

1. 정해진 무게를 넘지 않도록 배낭에 물건을 담는다.
1. 각 물건은 가치를 가지는데, 1의 조건을 만족할 때 가치의 최댓값을 구하자

```pseudocode
K[n, W]

FOR i in 0 → n : K[i, 0] ← 0
FOR w in 0 → W : K[0, w] ← 0

FOR i in 1 → n 
	FOR w in 1 → W
		IF wi > w               -- 가방에 넣을 수 없는 상황
			K[i, w] ← K[i-1, w]               
    ELSE                    -- 가방에 넣을 수 있는 상황
      K[i, w] ← max(vi + K[i-1, w - wi], K[i-1, w])
        	
RETURN K[n, W]
```

- 선물을 1 ~ N 번 까지 담을 수 있다고 할 때, 선물의 개수 i 를 순차적으로 늘려간다. 
  - 1번 선물까지 고려했을 때, 가치의 최댓값 
  - 1 ~ 2번 선물까지 고려했을 때,  가치의 최댓값
  - 1 ~ 3 번 선물까지 고려했을 때, 가치의 최댓값 => 이전까지의 가치의 최댓값을 이용!
- 배낭 무게를 1 ~ W 까지 담을 수 있다고 할 때, 무게 w 를 순차적으로 늘려간다.

-  IF => 가방에 넣을 수 없는 경우 (무게를 초과하여)

- ELSE => 가방에 담을 수 있는 경우 
  - v~i~ + K[i-1, w-w~i~] : 가방에 담는다. (현재 가치 + 무게가 w-w~i~ 일 때의 최대 가치 ) 
  - K[i-1, w] : 가방에 담지 않는다. ()	

![image-20211212150945008](Knapsack.assets/image-20211212150945008.png)

- i, w 를 순차적으로 늘려가는 이유는, 상향식으로 최적해를 찾아가기 때문.

  
